///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright Nurve Networks LLC 2008
//
// Filename: XGS_PIC_GAMEPAD_DRV_V010.c
//
// Original Author: Joshua Hintze
//
// Last Modified: 8.31.08
//
// Description: Gamepad library file
//
//
//
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// INCLUDES
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// First and foremost, include the chip definition header
#include "p24HJ256GP206.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


// include local XGS API header files
#include "XGS_PIC_SYSTEM_V010.h"
#include "XGS_PIC_GAMEPAD_DRV_V010.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MACROS
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 5 clock cycle delay to slow down gamepad reading
#define DELAY_5CLKS { NOP; NOP; NOP; NOP; NOP; }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DEFINES
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define GAMEPAD_DATA0_MASK	0x01		// Located on pin RD0
#define GAMEPAD_DATA1_MASK	0x02		// Located on pin RD1
#define GAMEPAD_LATCH_MASK	0x04		// Located on pin RD2
#define GAMEPAD_CLOCK_MASK	0x08		// Located on pin RD3

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// GLOBALS
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// EXTERNALS
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PROTOTYPES
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// FUNCTIONS
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// I/O pin map for game controllers
//
// GAMEPAD_DATA0 	  | RD0 | Pin 46 | Input
// GAMEPAD_DATA1 	  | RD1 | Pin 49 | Input
// GAMEPAD_DATA_LATCH | RD2 | Pin 50 | Output
// GAMEPAD_CLK        | RD3 | Pin 51 | Output
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Gamepad_Init()
{
	// this function intializes the gamepad, more or less simply sets the I/O ports in the correct direction and state.
	// Must be called before using the read function, unless the I/O ports have been setup correctly elsewhere

	// set data direction of gamepad I/O pins to receive inputs
	GAMEPAD_DATA0_TRIS = PIN_DIR_INPUT;
	GAMEPAD_DATA1_TRIS = PIN_DIR_INPUT;

	// set data direction of gamepad control pins as outputs
	GAMEPAD_DATA_LATCH_TRIS	= PIN_DIR_OUTPUT;
	GAMEPAD_CLK_TRIS = PIN_DIR_OUTPUT;

} // end Gamepad_Init



unsigned char Gamepad_Read(int GamepadNum)
{
	unsigned char GamepadState = 0;
	unsigned char DataMask = (GamepadNum == GAMEPAD_0) ? GAMEPAD_DATA0_MASK : GAMEPAD_DATA1_MASK;
	int i;

	// First step is to make sure clock is low and latch is high
	LATD &= ~GAMEPAD_CLOCK_MASK;
	LATD |= GAMEPAD_LATCH_MASK;
	DELAY_5CLKS;

	// Strobe the clock high
	LATD |= GAMEPAD_CLOCK_MASK;
	// Delay since we are so fast
	DELAY_5CLKS;

	// Strobe the clock low
	LATD &= ~GAMEPAD_CLOCK_MASK;
	DELAY_5CLKS;


	// Remove latch high
	LATD &= ~GAMEPAD_LATCH_MASK;
	DELAY_5CLKS;

	for(i=0; i < 8; i++)
	{
		GamepadState = GamepadState << 1;
		if(PORTD & DataMask)
			GamepadState |= 0x01;

		// Strobe the clock high then low
		LATD |= GAMEPAD_CLOCK_MASK;
		DELAY_5CLKS;
		LATD &= ~GAMEPAD_CLOCK_MASK;
		DELAY_5CLKS;
	}

	return ~GamepadState;
} // end Gamepad_Read



